# `labbook.yaml` 设计哲学与规范

**文档目的:** 本文档旨在清晰地阐述 `labbook.yaml` 文件在 `Labbook` 规范中的核心定位、设计原则以及字段规范。它是为了确保所有协作者（包括人类与AI）都能对 `labbook.yaml` 的职责范围有一个统一且明确的理解。

## 1. 核心定位：实验的“名片”

`labbook.yaml` 的核心定位是整个 `Labbook` 实验的**元数据清单 (Metadata Manifest)**，或者说是实验的“名片”和“封面”。

它的唯一职责是回答一个高层级的问题：**“这个实验是什么？”**

它**不负责**回答以下问题：

- “这个实验如何搭建环境？” (这是 `network/` 的职责)
- “这个实验如何一步步运行？” (这是 `timeline.yaml` 的职责)

通过这种严格的职责分离，我们确保了 `labbook.yaml` 的简洁性、稳定性和明确性。

## 2. 设计决策与思考过程

在设计过程中，我们曾探讨过是否应赋予 `labbook.yaml` 更多的功能，例如声明依赖或定义全局配置。经过深入分析，我们最终**拒绝**了这些方案，其决策理由如下：

### 2.1. 为什么不在这里声明依赖？

我们曾考虑在 `labbook.yaml` 中明确列出实验所使用的所有 `events`, `queries`, 和 `monitors`。

**否决原因：**

- **违反“单一数据源”原则 (Single Source of Truth):** `timeline.yaml` 已经通过 `action.source` 字段隐式地、准确地定义了所有依赖。在 `labbook.yaml` 中重复声明会造成数据冗余。一旦流程变更，就必须在两个文件之间手动同步，这极易引入错误和不一致。
- **流程的完整性应由 `timeline.yaml` 保证:** 一个实验的完整流程定义，其本身就包含了所有依赖信息。执行引擎应该通过扫描 `timeline.yaml` 来获取依赖列表，而不是依赖一个可能过时的外部清单。

### 2.2. 为什么不在这里定义全局配置？

我们也曾考虑在 `labbook.yaml` 中为某些动作提供全局的、默认的参数（例如，为所有 `monitor` 设置一个默认的采样间隔）。

**否决原因：**

- **破坏步骤的“自包含性”:** 我们坚持 `timeline.yaml` 中的每一步都应该是清晰、完整、自包含的。引入全局配置会产生“隐式”行为，理解一个步骤的完整逻辑需要同时查看多个文件，这会大大降低可读性和可维护性。
- **清晰性优于简洁性 (Clarity over Conciseness):** 在 `timeline.yaml` 的每个 `action` 中显式地提供所有参数，虽然可能造成少量重复，但它换来的是无与伦比的清晰度和确定性。任何阅读者都能在单一上下文中准确理解每一步的行为。
- **“减少重复”是上层工具的职责:** 模板渲染、参数化生成等便利性功能，应该由 `Labbook` 生态中的上层工具（如代码生成器）来负责。`Labbook` 数据契约本身，必须保持这份“笨拙”但极其可靠的清晰。

## 3. 最终规范

基于以上原则，`labbook.yaml` 的最终规范如下：

- **`apiVersion` (string, 必需):** `Labbook` 规范的版本号 (e.g., `"labbook.io/v1"`)。用于保证工具的向后兼容性。
- **`kind` (string, 必需):** 对象类型，固定为 `"Labbook"`。
- **`metadata` (object, 必需):** 包含所有描述性信息的对象。
    - **`name` (string, 必需):** 供机器使用的唯一标识符。
    - **`description` (string, 可选):** 供人类阅读的、对实验目的和设计的详细文字描述。
    - **`author` (string, 可选):** 实验的设计者或团队。
    - **`tags` (array of strings, 可选):** 用于实验分类、搜索和大规模管理的一组标签。

## 4. 结论

`labbook.yaml` 的设计严格遵循**关注点分离**的原则。它只做一件事并把它做好：**提供高层级的、用于识别和分类的元数据**。

这种看似“克制”的设计，赋予了整个 `Labbook` 体系以健壮性、清晰性和未来的可扩展性。任何协作者都可以确信，当他们拿起一份 `Labbook` 时，`labbook.yaml` 就是理解其身份的最快、最可靠的入口。