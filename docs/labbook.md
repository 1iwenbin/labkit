# Labbook 最终规范总览

# Labbook 最终规范总览

**文档目的:** 本文档是 `Labbook` 规范的最终、完整定义。它汇集了我们所有关于静态环境定义、动态流程编排、核心设计哲学及各组件字段的最终决策，旨在为 `Labbook` 的实现者和使用者提供一份清晰、健壮且无歧义的技术纲领。

## 1. 核心设计哲学：三层架构模型

`labbook` 的整个生态系统，被清晰地划分为三个层次，各司其职。这一模型是我们所有具体设计决策的基石。

### 1.1. 上游：智能的生成工具 (Python SDK / UI)

- **职责：** **追求极致的易用性与灵活性。**
- **功能：** 这一层是直接面向研究者的。它应该提供极其友好和强大的接口，例如支持模板、变量和循环，以编程方式轻松生成复杂的参数化实验。
- **输出：** 这个工具层的**最终输出**，是一份**完整的、明确的、可能包含大量冗余但绝无歧义的 `labbook` 目录**。

### 1.2. 中游：纯粹的数据契约 (`labbook` 目录)

- **职责：** **追求极致的明确性、规范性与自包含性。**
- **形态：** 这是本规范定义的**核心**。它是由上游工具生成的、保存在磁盘上的最终产物。它的设计原则是“所见即所得”，每一个文件都代表一个具体、完整的定义，没有任何隐藏的逻辑或对外部参数的依赖。
- **优点：** 这份数据契约逻辑扁平、清晰、无歧义，使得任何下游工具都可以对其进行简单、可靠的解析和执行。

### 1.3. 下游：简单而强大的执行引擎 (Go 平台)

- **职责：** **追求极致的稳定性和执行效率。**
- **输入：** 它只接收并信任中游的“纯粹数据契约”。
- **功能：** 由于输入的数据契约是如此的简单和明确，执行引擎的实现可以变得非常轻松和健壮，无需支持复杂的逻辑推断或模式切换。

## 2. 最终目录结构

一个标准的 `Labbook` 遵循以下目录布局：

```
[experiment-name]/
│
├── labbook.yaml            # [必需] 清单文件，实验的元数据
│
├── network/                # [必需] 静态环境定义
│   ├── config.yaml         #  - 网络的“蓝图”文件
│   └── mounts/             #  - [可选] 存放所有待挂载内容的“源目录”
│
├── playbook.yaml           # [必需] 动态流程编排文件，实验的“剧本”
│
├── events/                 # [可选] “事件”定义库 (自包含的任务)
├── queries/                # [可选] “查询”定义库 (自包含的任务)
├── monitors/               # [可选] “监控器”定义库 (自包含的任务)
└── scripts/                # [可选] 用户自定义的评估脚本

```

## 3. 静态环境规范 (`network/config.yaml`)

这是静态环境的核心定义文件，采用 YAML 格式。

- **顶层字段:** `images`, `nodes`, `switches`, `links`。
- **`images`:** 定义镜像别名，支持从 `registry` (简写/全写) 和 `tar` (全写) 两种来源。
- **`nodes`:** 定义所有计算节点。
    - **`interfaces`:** 每个接口必须包含 `name` 和 `mode`。
        - **`mode`:** 接口的工作模式，必须是 `direct`, `switched`, `gateway`, `host` 之一。它静态地、预先地定义了接口的能力。
        - `ip` 字段支持字符串或字符串列表，以配置单/多IP。
        - `gateway` 字段用于 `host` 模式的接口，指明其所属的 `gateway` 接口。
    - **`volumes`:** 支持 Docker 风格的简写形式 (`src:dest:mode`) 和全写对象形式。
- **`switches`:** 显式定义所有虚拟交换机（L2广播域）。
- **`links`:** 定义节点间的逻辑通信路径。`endpoints` 必须包含正好两个成员，可选的 `switch` 字段用于实现交换式连接。

## 4. 动态流程规范 (`playbook.yaml`)

这是实验的“剧本”，采用**双轨制执行模型**。它的核心职责是作为**纯粹的编排器**，只负责在正确的时间点，指向正确的能力定义文件。

- **`conditions` 块 (条件库):** 定义可复用的“条件”。
    - **`type`:** 支持两种模式：`declarative` (默认，通过 `query` + `rule` 检查) 和 `command` (通过在目标节点内执行 `command` 并检查其退出码来判断)。
- **`timeline` 块 (背景时间线):**
    - 定义一系列**不可阻塞的、按绝对时间戳 (`at`) 触发的异步背景事件**。它构成了“动态变化的世界”。
    - 此块中的步骤**不允许**使用 `wait_for`。
- **`procedure` 块 (实验规程):**
    - 定义一个或多个独立的、**可阻塞的同步测试序列**。这是实验者想要执行的核心测试流程。
    - 每个规程 (`procedure`) 对象包含 `id`, `trigger_at` (启动时间点), 和一个 `steps` 列表。
    - `steps` 列表中的步骤是**串行执行**的，**不包含 `at` 字段**。
- **步骤 (Step) 的行为:**
    - **`action`:** 执行一个单一的、原子的操作。
    - **`run_if`:** **非阻塞**的条件执行。只在当前步骤检查一次条件，决定是否执行其包含的 `action`，不影响后续步骤。
    - **`wait_for`:** **只能在 `procedure` 中使用**。它会**阻塞**当前所在的 `procedure`，直到条件满足或超时，不影响 `timeline` 或其他 `procedure`。

## 5. 能力定义文件 (`events/`, `queries/`, `monitors/`)

这是我们三层架构模型中，`labbook` 数据契约的核心体现。

- **角色定位:** 它们不再是通用的“模板”或“函数库”，而是**具体的、自包含的“任务”定义**。
- **核心原则:** 每一个能力定义文件，都必须完整地包含执行该任务所需的**所有信息**。
- **文件内容:**
    - `name`, `description`: 任务的基本描述。
    - `type`: `event`, `query`, 或 `monitor`。
    - `target`, `with`: **任务自己的参数。** 如果一个任务需要参数，它们被定义在这里，而不是在 `playbook.yaml` 中。
    - `assert`: **任务自己的期望结果。** 如果一个 `query` 任务需要验证其结果，断言逻辑被定义在这里。

**示例：`queries/check-primary-path.yaml`**

```
name: "query.check-primary-path"
description: "一个自包含的任务：检查到8.8.8.8的路由是否在主路径上。"
type: query

# 任务的目标和参数被硬编码在这里
target: "core-router-1"
with:
  destination: "8.8.8.8"

# 任务的期望结果也被硬编码在这里
assert:
  - path: "result.nexthop"
    rule: equals
    value: "10.0.1.2"

```

**`playbook.yaml` 中的调用 (纯指针):**

```
- at: "10s"
  description: "执行主路径检查任务"
  action:
    # playbook 中只有一个指向任务文件的纯粹指针
    source: "queries/check-primary-path.yaml"

```

# 从哲学层面审视 Labbook：一份关于“计算实验”的契约

在完成了对 `labbook` 规范所有技术细节的打磨之后，我们有必要退后一步，从一个更高的、更抽象的哲学层面，来审视我们共同构建的这套体系。我们最初的愿景，是创造一个自描述的、可复现的、清晰的、强大的网络仿真实验规范。我们是否真正达成了这一目标？

答案是肯定的。`labbook` 的设计，不仅在功能上满足了需求，更重要的是，它在底层的设计哲学上，构建了一套完备、自洽且优雅的逻辑体系。其完备性，体现在以下四个核心的哲学支柱之上。

## 支柱一：作为科学契约的完备性 (Completeness as a Scientific Contract)

科学的基石是**可复现性 (Reproducibility)**。一个实验如果没有被清晰地记录下来，以至于他人无法独立复现其过程和结果，那么它在科学上就是无效的。

`labbook` 的整个设计，都服务于这一最高原则。它不仅仅是一套配置文件，它是一份**数字化的、可执行的科学实验记录**。

- **自包含性即复现性：** 我们最终确立的“纯指针”和“自包含任务文件”模型，确保了一个 `labbook` 目录本身，就是对一次实验所有初始条件、动态过程和预期结果的**完整快照**。理论上，任何拥有兼容执行引擎的研究者，在拿到这份 `labbook` 后，都应该能够精确地复现出完全相同的实验过程。这正是科学精神的数字化体现。
- **明确性即严谨性：** 我们坚持将参数和断言定义在具体的任务文件中，而不是依赖于 `playbook.yaml` 中的 `description`。这本质上是坚持**“数据优先于文档”**的原则。就像在科学记录中，精确的测量数据（`with`, `assert`）远比描述性的文字（`description`）更重要、更可信。这保证了 `labbook` 作为一份科学记录的严谨性。

## 支柱二：作为声明式语言的纯粹性 (Purity as a Declarative Language)

在自动化领域，存在两种根本不同的范式：命令式 (Imperative) 和声明式 (Declarative)。

- **命令式 (“如何做”):** 编写一个脚本，一步步地告诉机器“先做A，再做B，然后判断C”。
- **声明式 (“是什么”):** 描述一个最终的期望状态，让系统自己去想办法达成。

我们最终的设计，在 `playbook.yaml` 的顶层，坚定地选择了**声明式**。

- **`playbook.yaml` 的声明本质：** 它声明了“在时间线 (`timeline`) 这个背景下，需要并行启动名为 `procedure-A` 和 `procedure-B` 的两个规程”。它不关心这两个规程内部的执行细节，只负责声明这个最终的编排意图。
- **封装命令式：** 与此同时，我们通过 `procedure` 的串行步骤和 `command` 类型的条件，巧妙地将**命令式**的逻辑封装在了更低的层次。这允许用户在需要时，可以进行精细的过程控制。

`labbook` 通过这种**“顶层声明式，底层可命令式”**的混合设计，既享受了声明式带来的清晰、简洁和健壮性，又没有失去命令式所提供的灵活性，达到了完美的平衡。

## 支柱三：作为系统设计的解耦性 (Decoupling as a System Design)

一个伟大的设计，必然是一个高度解耦的设计。`labbook` 的完备性，很大程度上来源于其在多个维度上实现的清晰解耦。

- **静态与动态的解耦：** `network/` 目录定义了“舞台”的样子，`playbook.yaml` 定义了“舞台上发生的故事”。两者职责分离，互不干扰。
- **背景与前景的解耦：** `timeline` 定义了不可阻塞的“世界背景”，`procedure` 定义了可阻塞的“主角行动”。这使得我们可以模拟出在动态环境中进行精确测试的复杂场景。
- **“定义”与“使用”的解耦：** `conditions` 块将“条件的定义”与流程中对条件的“使用” (`run_if`, `wait_for`) 分离开来，极大地增强了逻辑的清晰度和可复用性。
- **最重要的一点——“易用性”与“规范性”的解耦：** 这是我们最终达成的**三层架构模型**的精髓。
    - **规范 (中游):** 追求极致的明确和无歧义。
    - **执行引擎 (下游):** 因规范的明确而变得简单、健壮。
    - **生成工具 (上游):** 可以在不污染核心规范的前提下，尽情地为用户提供模板、变量、循环等各种“易用性”功能。

## 支柱四：作为演化基础的健壮性 (Robustness as a Foundation for Evolution)

一个设计是否完备，不仅要看它能否解决当前的问题，更要看它是否为未来的演进留下了清晰的路径。

- **原子化设计的力量：** 我们坚持将 `playbook` 中的所有步骤都设计为原子化的。这使得我们未来可以轻松地增加新的步骤类型（比如 `loop` 或 `try/catch`），而不会破坏现有的执行模型。
- **接口优先的原则：** 我们在 `config.yaml` 中确立了“接口的 `mode` 决定了 `link` 的合法性”这一原则。这使得我们的网络定义极其健壮，为未来支持更复杂的接口类型（如 `vlan`, `vxlan`）打下了坚实的基础。
- **双轨制条件的扩展性：** `declarative` 和 `command` 的双轨制，为平台未来的发展指明了方向。平台可以不断地将用户在 `command` 中反复实现的、有普遍价值的逻辑，“吸收”并固化为新的、高效的 `declarative` 规则，从而实现平台的持续有机成长。

## 最终结论

是的，我们共同设计的 `labbook` 规范，在哲学层面上是完备的。它不仅仅是一套文件格式，它是：

- 一份**严谨的科学契约**，保证了实验的可复现性。
- 一门**优雅的声明式语言**，清晰地描述了复杂的动态流程。
- 一个**高度解耦的系统设计**，明确了生态中各组件的职责。
- 一个**面向未来的演化基石**，为平台未来的成长提供了无限可能。

# Labbook 设计之旅：从愿景到规范的完整回顾

**文档目的:** 本文档旨在系统性地回顾和总结我们关于 `labbook` 规范的完整设计过程。它记录了我们从最初的愿景出发，经过对核心哲学的反复辩论和对技术细节的深入打磨，最终达成的一系列关键共识。

## 1. 核心哲学：最终确立的三层架构模型

这是我们整个设计的基石，也是我们所有分歧最终得以统一的理论基础。

- **上游 (生成工具):** **追求易用性**。这一层是直接面向研究者的 Python SDK 或 UI。它应该提供模板、变量、循环等便利功能，让用户能以最简单的方式描述复杂的实验。
- **中游 (数据契约):** **追求明确性**。这是由上游工具生成的、保存在磁盘上的 `labbook` 目录。它的核心原则是“所见即所得”，可能包含大量“笨拙”的、重复的但绝无歧义的自包含任务文件。
- **下游 (执行引擎):** **追求稳定性**。Go 平台作为执行引擎，只接收并信任这份纯粹、明确的数据契约。由于输入是如此的简单和规范，引擎的实现可以变得非常健壮和高效。

## 2. 静态环境 (`network/`) 的最终设计

我们为实验的“舞台”搭建，确立了清晰的规范。

- **目录结构:** `network/` 包含一个核心的 `config.yaml` 文件和一个可选的 `mounts/` 目录。`mounts/` 用于存放所有待挂载的文件，其子目录以节点ID命名，实现了“约定优于配置”。
- **`config.yaml`:**
    - **顶层字段:** `images`, `nodes`, `switches`, `links`。
    - **`images`:** 成为一个集中的“镜像来源清单”，支持从 `registry` 和本地 `tar` 包两种方式获取，并通过别名实现统一管理。
    - **`nodes`:** 节点定义的核心是其 `interfaces` 列表。
        - **`mode` 字段:** 我们最终确定了 `direct`, `switched`, `gateway`, `host` 这四种工作模式。这个字段静态地、预先地定义了接口的能力，并成为后续 `links` 定义合法性的约束。
        - **`ip` 字段:** 支持字符串或字符串列表，以配置单/多IP。
        - **`volumes` 字段:** 支持 Docker 风格的简写形式 (`src:dest:mode`) 和全写对象形式，兼顾了易用性与清晰性。
    - **`switches` & `links`:** 我们最终确立了将“虚拟交换机”作为一等公民的设计。`switches` 块显式定义所有L2广播域，而 `links` 则通过可选的 `switch` 字段来引用它们，清晰地区分了“点对点直连”和“交换式连接”。

## 3. 动态流程 (`playbook.yaml`) 的最终设计

这是我们讨论最深入、也是设计演进最精彩的部分，它定义了实验的“剧本”。

- **最终命名:** 我们从 `timeline` -> `workflow` -> `scenario`，最终确定了 **`playbook.yaml`** 这个最能体现“自动化剧本”和“行动纲领”含义的名称。
- **双轨制执行模型:** 这是设计的核心突破。
    - **`timeline` (背景时间线):** 定义一系列**不可阻塞的、按绝对时间戳 (`at`) 触发的异步背景事件**。它构成了“动态变化的世界”。
    - **`procedure` (实验规程):** 定义一个或多个独立的、**可阻塞的同步测试序列**。这是实验者想要执行的核心测试流程。
- **流程控制:**
    - **`run_if` (类似 `if`):** 一个**非阻塞**的条件执行步骤。它只在当前步骤检查一次条件，决定是否执行其包含的 `action`，**不影响**后续步骤。
    - **`wait_for` (类似带超时的 `while`):** 一个**阻塞性**的等待步骤，**只能在 `procedure` 中使用**。它会暂停其所在的 `procedure`，直到条件满足或超时，但**不影响**全局的 `timeline` 或其他 `procedure` 的执行。
- **条件 (`conditions`):**
    - 我们设计了可复用的 `conditions` 块，以实现“定义”与“使用”的分离。
    - 最重要的是，我们确立了**双模式条件**：`declarative` (平台提供的内置高效检查) 和 `command` (用户提供的无限灵活的脚本检查)，为平台提供了强大的“逃生舱口”。

## 4. 能力定义 (`events/`, `queries/` 等) 的最终设计

这是我们“三层架构模型”的最终体现。

- **角色定位:** 这些目录下的文件，不再是通用的“模板”或“函数库”，而是**具体的、自包含的“任务”定义**。
- **核心原则:** 每一个能力定义文件，都必须完整地包含执行该任务所需的**所有信息**，包括它自己的参数 (`with`) 和期望结果 (`assert`)。
- **`playbook.yaml` 的角色:** 在 `playbook.yaml` 中，对这些能力的调用是一个**纯粹的“指针”**。`action` 块中只有一个 `source` 字段，指向对应的任务文件。
- **底层实现 (`node.execute`):** 我们最终为底层的 Go 执行器，设计了一套包含 `DaemonMode`, `ReturnOutput`, `OutputPath` 等字段的 `CommandConfig` 规范，它可以用最少的字段，正交地、清晰地定义出所有需要的执行模式。

非常感谢您！正是因为您每一次都坚持己见、深入思考并提出有力的反驳，我们才能不断地审视和完善我们的设计，最终抵达这个逻辑上完备、哲学上自洽、工程上健壮的最终形态。

期待我们下一次的讨论！